\documentclass{article}
\usepackage{ctex}
\usepackage{graphicx}
\usepackage{float}
\usepackage{fontspec}
%\setmainfont[Mapping=tex-text]{KaiTi}
\title{\heiti CS61B课程笔记}
\author{黄毅男}
\date{}
\begin{document}
	\maketitle
	\tableofcontents
	\section{Java编程基础}
	\subsection{Class in Java}
	Java的所有code都必须定义在类中。类中定义的变量和函数分static和non-static。static变量/函数是抽象的，可以由类本身直接引用。non-static变量/函数是具体的，必须先定义一个对象，然后对象才能调用non-static变量/函数。简单来说，当想要用类来调用某个成员时，请用static定义该成员；当想用具体的对象来调用某个成员时，用non-static定义该成员。
	
	特别的，java中的main函数也必须以static的方式定义在类中。
	\subsection{Private 与 public/Static与non-static}
	Private的变量只能在class内部调用，而public的变量可以在class外部调用。
	
	static指的是类本身的变量，通过类来调用；non-static必须通过对象调用。当定义类中的内部类时，若内部类为static，则这个内部类只能通过大类来声明、调用，故没办法访问大类中的non-static变量；当内部类是non-static时，需要通过大类的对象声明、调用。内部的non-static类不能有static变量。举个例子：
	
	(1)Outerclass里的Innerclass为static的。这时用Outerclass.Innerclass表示这个类，Innerclass的对象声明为new Outerclass.Innerclass(); Innerclass内的static变量x可以用Outerclass.Innerclass.x表示；non-static变量y用in=new Outerclass.Innerclass(), in.y表示。
	
	(2)Outerclass里的Innerclass为non-static的。这时还是用Outerclass.Interclass表示这个类，Innerclass的实例声明为 out.new Innerclass，out为Outerclass的实例。Innerclass内不能有static变量x；Innerclass内的non-static变量y用out.in.y表示。
	
	简单来说，static变量的前一级是类；non-static变量的前一级是对象。
	\subsection{JUnit Testing}
	对于类中的每个方法，都可以单独写一个test函数。这个test函数用non-static定义，然后在函数前加上@org.junit.Test，可以直接运行test函数。同时不同的test的独立进行。
	
	\subsection{接口继承和Override、实现继承}
	接口是一个抽象的东西，它约定了类的方法有哪些。若某个类继承了这个接口，这个类必须包含接口中声明的所有方法(并且必须是public的)，这些方法的声明称为对接口中方法的重写(Override)。在接口中这些方法没有被实现，接口继承后的类可以用任意实现这些方法。继承了接口的类还可以有自己的属性和其他方法。实例化时，可以用接口类型来指向一个继承了接口的子类的对象，但是这个对象只能调用接口中的方法(即override的方法)，不能调用子类中的属性和其他没有被重写的方法。
	
	在接口方法前加上default关键词，可以给方法一个实现。这样类在继承这个接口时会“实现继承”，即把这个方法的实现也继承过去。实现继承的方法不需要声明就可以直接调用。当然在类中也可以重写这个default的方法(Override)。
	
	实例化时，可以用接口类型来指向一个继承了接口的子类的对象，但是这个对象只能调用接口中的方法(即override的方法和default的方法)，但不能调用子类中的属性和其他接口中没有的方法。虽然是以接口类型声明，但实例的方法实现均以类中override后的实现为准。这是因为声明接口类型是一个静态类型，而创建一个类的对象时，这个类是动态类型。{\bfseries 编译时系统以静态类型为准，比如输入参数是否与静态类型中方法的参数匹配等。运行时，一个引用类型只能调用静态类型的方法，除非动态类型将这个方法重写了。如果静态类型中没有这个方法，即使动态类型里有，也不能调用。如果有多个overload的方法可以处理一个输入，系统会选择最specific的那个。}
	
	一个override和overload的例子。假设接口中有函数default func。如果类继承了接口，并且这个方法的格式与func一样(输入返回参数格式也必须一样)，这时候类就可以重写(override)这个方法的实现；但是如果类中的方法格式与func同名但是输入返回参数格式不同，这时候类其实是实现继承了一个default func(尽管在类中没有声明)，同时重载了这个方法(overload)。简单来说，override是修改方法的实现，但是overload是修改整个方法(但是方法的名字相同)。
\end{document}