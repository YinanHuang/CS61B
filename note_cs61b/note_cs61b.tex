\documentclass{article}
\usepackage{ctex}
\usepackage{graphicx}
\usepackage{float}
\usepackage{fontspec}
%\setmainfont[Mapping=tex-text]{KaiTi}
\title{\heiti CS61B课程笔记}
\author{黄毅男}
\date{}
\begin{document}
	\maketitle
	\tableofcontents
	\section{Java编程基础}
	\subsection{Class in Java}
	Java的所有code都必须定义在类中。类中定义的变量和函数分static和non-static。static变量/函数是抽象的，可以由类本身直接引用。non-static变量/函数是具体的，必须先定义一个对象，然后对象才能调用non-static变量/函数。简单来说，当想要用类来调用某个成员时，请用static定义该成员；当想用具体的对象来调用某个成员时，用non-static定义该成员。
	
	特别的，java中的main函数也必须以static的方式定义在类中。
	\subsection{Private 与 public/Static与non-static}
	Private的变量只能在class内部调用，而public的变量可以在class外部调用。
	
	static指的是类本身的变量，通过类来调用；non-static必须通过对象调用。当定义类中的内部类时，若内部类为static，则这个内部类只能通过大类来声明、调用，故没办法访问大类中的non-static变量；当内部类是non-static时，需要通过大类的对象声明、调用。内部的non-static类不能有static变量。举个例子：
	
	(1)Outerclass里的Innerclass为static的。这时用Outerclass.Innerclass表示这个类，Innerclass的对象声明为new Outerclass.Innerclass(); Innerclass内的static变量x可以用Outerclass.Innerclass.x表示；non-static变量y用in=new Outerclass.Innerclass(), in.y表示。
	
	(2)Outerclass里的Innerclass为non-static的。这时还是用Outerclass.Interclass表示这个类，Innerclass的实例声明为 out.new Innerclass，out为Outerclass的实例。Innerclass内不能有static变量x；Innerclass内的non-static变量y用out.in.y表示。
	
	简单来说，static变量的前一级是类；non-static变量的前一级是对象。
	\subsection{JUnit Testing}
	对于类中的每个方法，都可以单独写一个test函数。这个test函数用non-static定义，然后在函数前加上@org.junit.Test，可以直接运行test函数。同时不同的test的独立进行。
	
	\subsection{接口继承和Override、实现继承}
	接口是一个抽象的东西，它约定了类的方法有哪些。若某个类继承了这个接口，这个类必须包含接口中声明的所有方法(并且必须是public的)，这些方法的声明称为对接口中方法的重写(Override)。在接口中这些方法没有被实现，接口继承后的类可以用任意实现这些方法。继承了接口的类还可以有自己的属性和其他方法。实例化时，可以用接口类型来指向一个继承了接口的子类的对象，但是这个对象只能调用接口中的方法(即override的方法)，不能调用子类中的属性和其他没有被重写的方法。
	
	在接口方法前加上default关键词，可以给方法一个实现。这样类在继承这个接口时会“实现继承”，即把这个方法的实现也继承过去。实现继承的方法不需要声明就可以直接调用。当然在类中也可以重写这个default的方法(Override)。
	
	实例化时，可以用接口类型来指向一个继承了接口的子类的对象，但是这个对象只能调用接口中的方法(即override的方法和default的方法)，但不能调用子类中的属性和其他接口中没有的方法。虽然是以接口类型声明，但实例的方法实现均以类中override后的实现为准。这是因为声明接口类型是一个静态类型，而创建一个类的对象时，这个类是动态类型。{\bfseries 编译时系统以静态类型为准，比如输入参数是否与静态类型中方法的参数匹配等。运行时，一个引用类型只能调用静态类型的方法，除非动态类型将这个方法重写了。如果静态类型中没有这个方法，即使动态类型里有，也不能调用。如果有多个overload的方法可以处理一个输入，系统会选择最specific的那个。}
	
	一个override和overload的例子。假设接口中有函数default func。如果类继承了接口，并且这个方法的格式与func一样(输入返回参数格式也必须一样)，这时候类就可以重写(override)这个方法的实现；但是如果类中的方法格式与func同名但是输入返回参数格式不同，这时候类其实是实现继承了一个default func(尽管在类中没有声明)，同时重载了这个方法(overload)。简单来说，override是修改方法的实现，但是overload是修改整个方法(但是方法的名字相同)。
	
	\subsection{函数作为输入参数}
	java不能直接把函数作为输入参数，因为函数不是一个数据类型。一般的方法是，首先定义一个接口(比如叫做func)，所有的函数都继承这个接口中apply方法(即调用这个函数本身)。这样在调用函数时，我们可以先实例化这个函数，得到一个func对象，然后定义一个以func对象为输入参数的函数，这样就可以达到“构造一个以函数为输入参数的函数”的目的了。
	
	\subsection{Casting}
	Casting是java中变换静态类型的一种方法。我们知道，一个赋值操作a=b是否能编译，取决于a的类型A是否是b的类型B的上义词。若B是A的下义词，编译会失败。这时我们可以用a=(A) b的casting方法来临时将后边的表达式的静态类型变为A“，骗过”编译器从而编译成功。不过需要注意的是，即使通过了编译器，运行也可能报错。cast赋值后，对象的静态类型比动态类型小，这时候run-time会报错。比如(Small) new Big(...)，本来表达式new Big(...)的静态类型和动态类型都是上义词Big，但是其静态类型被Casting为Small，这时候静态类型是动态类型的下义词，那么这个表达式虽然可以通过编译，但是在运行时会报错。总而言之，Casting可以任意提高静态类型，但是在降低静态类型时，务必不能低于动态类型的大小，否则会运行报错。
	
	{\bfseries 总结}：
	\begin{itemize}
		\item 编译时：检查赋值语句，被赋值方的静态类型必须是赋值方静态类型的上义词；检查方法调用语句，静态类型中必须有这个方法。
		\item 运行时：运行赋值语句时，每个对象的静态类型必须是其动态类型的上义词；运行方法调用语句时，从静态类型中选取最合适的方法调用，但如果这个方法被其动态类型override(只有下义词才能override，这就是为什么动态类型必须是静态类型的下义词)，那么调用动态类型中的方法。
	\end{itemize}
	\subsection{泛型}
	类的定义中可以带上泛型：public class xxx<any>，这里any就是一个泛型，代指某种引用类型。实际实例化时，需要将any用某个引用类型填入。
	
	方法的定义中也可以带上泛型，形式为 <any> any xxx()。实际使用时，不需要填入<any>，系统会自动根据对应关系确定any。
	
	\subsection{异常处理}
	Java中异常也是类，分为checked和unchecked。checked的异常，比如IO异常，必须被用try\& catch方法catch，或者在可能出现checked异常的类后加上throws声明。checked的异常如果不处理，则程序无法编译。unchecked的异常，比如运行异常，不会影响程序编译，但是运行到异常处程序会停止。
	
	\subsection{Package}
	定义一个package文件夹，里面的文件都在首行加上文件夹的path。这样是为了避免类的重名。引用类时，需要import这个package。不加package声明的文件都属于一个default package的package。
	
	\subsection{Access Control}
	一个field变量或者method(以下统称变量)，有几种access等级：public、protected、private以及默认的package private。public的变量是全局公开，可以被任意访问；protected的变量可以在类内部、同一个package里、其子类访问，除此之外的访问是不允许的。private只能在class内访问。默认的package private可以被类内部或者在同一package下访问。
	
	注意对于接口，其默认的是public而不是package private。
	
	对于类本身，也有access的问题。但是private和protected的modifier是无效的，public和默认的package private是可以的。
	

\end{document}